# -*- coding: utf-8 -*-
"""preprocess_data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O7hBCwdas1MINOUhbV6UXcytxPmikJ52
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.image as mpimg
import numpy as np
import matplotlib.pyplot as plt
import os,sys
from PIL import Image

from keras.preprocessing.image import ImageDataGenerator
from skimage import io

import tensorflow as tf
from tensorflow import keras

from sklearn.feature_extraction import image

from sklearn.model_selection import train_test_split

from data_augmentation import *
from load_helpers import *

def load_images(image_dir, gt_dir ):
  # Loaded a set of images

    files = os.listdir(image_dir)
    imgs = np.asarray([load_image(image_dir + files[i]) for i in range(len(files))])

    gt_imgs = np.asarray([load_image(gt_dir + files[i]) for i in range( len(files))])

    #for i in range( len(files)):
    #   print(files[i])
    return imgs, gt_imgs

def data_augment( imgs, gt_imgs,image_dir, gt_dir, max_iters ):
    
    
    augment_dataset2(imgs,gt_imgs,image_dir,gt_dir,max_iters)

    # Loaded a set of images
    files_aug = os.listdir(image_dir)
    imgs_aug = np.asarray([load_image(image_dir + files_aug[i]) for i in range(len(files_aug))])

    files_gt = os.listdir(gt_dir)

    gt_imgs_aug =np.asarray([ (load_image(gt_dir + files_aug[i]) if i<100  else load_image(gt_dir + files_gt[i]) ) for i in range(len(files_aug))])

    #gt_imgs_aug[100:]=np.asarray([load_image(gt_dir + files_gt[i]) for i in range(100, len(files_aug))])

    #for i in range( len(files_aug)):
    #   print(files_aug[i], files_gt[i])

    return imgs_aug, gt_imgs_aug

def get_patches(imgs, gt_imgs):
    n = len(imgs)

    # Extract patches from input images
    patch_size = 16 # each patch is 16*16 pixels

    img_patches = [img_crop(imgs[i], patch_size, patch_size) for i in range(n)]
    gt_patches = [img_crop(gt_imgs[i], patch_size, patch_size) for i in range(n)]

    # Linearize list of patches
    img_patches = np.asarray([img_patches[i][j] for i in range(len(img_patches)) for j in range(len(img_patches[i]))])
    gt_patches =  np.asarray([gt_patches[i][j] for i in range(len(gt_patches)) for j in range(len(gt_patches[i]))]) 

    return img_patches, gt_patches

def compute_features(img_patches, gt_patches , foreground_threshold):
  # Compute features for each image patch
  

    X = np.asarray([ img_patches[i] for i in range(len(img_patches))])
    Y = np.asarray([value_to_class_NN(gt_patches[i],foreground_threshold) for i in range(len(gt_patches))])
    
    return X, Y

def split(X, Y,test_ratio=0.2 ,  random_state=0):
  #split into train and test sets
  return train_test_split(X,Y, test_size=test_ratio, random_state=random_state )

def preprocess(root_dir, max_iters, random_state=0, test_ratio=0.2 , foreground_threshold = 0.25 , unet=False):
  #foreground_threshold = 0.25 is percentage of pixels > 1 required to assign a foreground label to a patch

    #get the images directory
    image_dir = os.path.join(root_dir, "images/")

    #get the grounftruth directory
    gt_dir =  os.path.join(root_dir, "groundtruth/")

    #Load the images and the corresponding grounthruths
    imgs, gt_imgs= load_images(image_dir, gt_dir)

  
    #perform data augmentation
    imgs_aug, gt_imgs_aug =data_augment(imgs, gt_imgs, image_dir, gt_dir ,max_iters )
        
  


    if(unet):
      print("unet")
      X= np.asarray(imgs_aug)

      #this is needed for the unet
      Y= np.expand_dims( np.asarray(gt_imgs_aug), axis=3)
      #Y= np.asarray(gt_imgs_aug)

    else:
      #divide images into patches
      img_patches, gt_patches=get_patches(imgs_aug, gt_imgs_aug)
      # Compute features for each image patch
      X, Y =compute_features(img_patches, gt_patches , foreground_threshold)

    #split the data into train and test sets
    X_train,X_test,Y_train,Y_test=train_test_split(X,Y, test_size=test_ratio, random_state=random_state)

    return X_train,X_test,Y_train,Y_test